/*/
 * 
 * Saboteur routine for disrupting other nests
 * 
/*/

function sdec_alone()
{
	//Actively avoid other allied workers
	for (try_cell of rand_perm(SCAN_MOVES))
		if (is_ally(try_cell) && view[CCW[try_cell][4]].ant === null) return {cell:CCW[try_cell][4]};

	var c = U_PANIC;
	for (try_cell of rand_sub(SCAN_MOVES, 7))
		if (view[try_cell].color > 1 && view[try_cell].color !== c) 
		{
			c = view[try_cell].color;
			break;
		}
	if (view[4].color === 1) return {cell: 4, color: c};
	//Try to move in straight lines
	for (try_cell of rand_perm(CORNERS))
		if (view[try_cell].color === 1 && view[CCW[try_cell][4]].color !== 1) 
			return {cell:try_cell};
	for (try_cell of rand_perm(CORNERS))
		if (view[try_cell].color === 1 && view[CCW[try_cell][2]].color !== 1 && view[CCW[try_cell][6]].color !== 1) 
			return {cell:try_cell};

	return {cell:1};
}

function sdec_erase()
{
	//Actively avoid other allied workers
	for (try_cell of rand_perm(SCAN_MOVES))
		if (is_ally(try_cell) && view[CCW[try_cell][4]].ant === null) return {cell:CCW[try_cell][4]};

	for (try_cell of rand_perm(SCAN_MOVES))
		if (view[try_cell].color !== 1) return {cell:try_cell, color:1};
	if (view[4].color !== 1) return {cell:4, color:1};

	return {cell:0};
}

function sdec_discolor()
{
	//Recolor squares, with a pattern that is surprisingly good at breaking deadlocks
	if (view[1].color !== view[6].color && view[6].color !== 1) return {cell:1, color:view[6].color};
	if (view[2].color !== view[3].color) return {cell:3, color:view[2].color};
	
	for (try_cell of rand_perm(EDGES))
		if (view[try_cell].color !== 1) 
			if (view[CCW[try_cell][1]] !== 1 && view[CCW[try_cell][7]] !== 1) 
				return {cell:try_cell};
	for (try_cell of rand_perm(CORNERS))
		if (view[try_cell].color !== 1) 
			if (view[CCW[try_cell][1]] !== 1 || view[CCW[try_cell][7]] !== 1) 
				return {cell:try_cell};

	//Stick around allies
	for (try_cell of rand_perm(SCAN_MOVES))
		if (is_ally(try_cell)) 
			return {cell:try_cell};

	return {cell:0};
}

function sdec_stride()
{
	var stride_scores = [0,0,0,0,0,0,0,0,0];
	for (try_cell of SCAN_MOVES)
	{
		if (view[try_cell].color !== view[CCW[try_cell][1]].color) stride_scores[try_cell] += 2;
		if (view[try_cell].color !== view[CCW[try_cell][7]].color) stride_scores[try_cell] += 2;
		if (view[try_cell].color !== view[CCW[try_cell][2]].color) stride_scores[try_cell] += 1;
		if (view[try_cell].color !== view[CCW[try_cell][6]].color) stride_scores[try_cell] += 1;
		if (view[try_cell].color !== view[4].color) stride_scores[try_cell] += 1;
	}
	var max_stride_score = Math.max(...stride_scores);
	for (var i = 0; i < 9; i++)
		if (stride_scores[i] === max_stride_score) return {cell:i};
	return {cell:0};
}

function sdec_obstruct_textured()
{
	var proximities = [0,0,0,0,0,0,0,0,0];
	for (try_cell of SCAN_MOVES)
	{
		if (is_enemy(try_cell))
		{
			proximities[try_cell]++;
			for (alt_cell of NEARS[try_cell]) proximities[alt_cell]++;
			for (alt_cell of NEIGHBORS[try_cell]) proximities[alt_cell]++;
		}
	}
	for (var i = 0; i < 9; i++)
		proximities[i] += ant_rand()%SABOTEUR_OBSTRUCT_FUZZ;
	var prox_order = index_sort(proximities);
		
	if (rand_choice(SABOTEUR_RECOLOR_PROB))
	{
		for (var i = 8; i > 0; i--)
		{
			var i_cell = prox_order[i];
			for (var j = 0; j < i; j++)
			{
				var j_cell = prox_order[j];
				if (view[i_cell].color !== view[j_cell].color)
					return {cell:i_cell, color:view[j_cell].color};
			}
		}
	}
	//Factor allies in
	for (try_cell of SCAN_MOVES)
	{
		if (is_ally(try_cell))
		{
			proximities[try_cell]++;
			for (alt_cell of NEARS[try_cell]) proximities[alt_cell]++;
			for (alt_cell of NEIGHBORS[try_cell]) proximities[alt_cell]++;
		}
	}
	//Update prox_order
	prox_order = index_sort(proximities);

	for (var i = 8; i >= 0; i--)
		if (view[prox_order[i]].ant === null) return {cell:prox_order[prox_order[i]]};
	return {cell:4, color:1};
}

function sdec_obstruct_flat()
{
	var proximities = [0,0,0,0,0,0,0,0,0];
	for (try_cell of SCAN_MOVES)
	{
		if (is_enemy(try_cell))
		{
			proximities[try_cell]++;
			for (alt_cell of NEARS[try_cell]) proximities[alt_cell]++;
			for (alt_cell of NEIGHBORS[try_cell]) proximities[alt_cell]++;
		}
	}
	for (var i = 0; i < 9; i++)
		proximities[i] += ant_rand()%SABOTEUR_OBSTRUCT_FUZZ;
	var prox_order = index_sort(proximities);
		
	if (rand_choice(SABOTEUR_RECOLOR_PROB))
	{
		for (var i = 8; i > 0; i--)
		{
			var i_cell = prox_order[i];
			if (view[i_cell].color !== D_MARCH)
				return {cell:i_cell, color:D_MARCH};
		}
	}
	//Factor allies in

	for (try_cell of SCAN_MOVES)
	{
		if (is_ally(try_cell))
		{
			proximities[try_cell]++;
			for (alt_cell of NEARS[try_cell]) proximities[alt_cell]++;
			for (alt_cell of NEIGHBORS[try_cell]) proximities[alt_cell]++;
		}
	}
	//Update prox_order
	prox_order = index_sort(proximities);

	for (var i = 8; i >= 0; i--)
		if (view[prox_order[i]].ant === null) return {cell:prox_order[prox_order[i]]};
	return {cell:4, color:1};
}

//Fallback function for workers
function saboteur()
{
	var colored_neighbors = 0;
	for (try_cell of SCAN_MOVES) 
		if (view[try_cell].color > 1) colored_neighbors++;

	if (colored_neighbors <= 2) return sdec_alone();
	else
	{
		var num_enemies = 0;
		for (try_cell of SCAN_MOVES)
			if (is_enemy(try_cell)) num_enemies++;
		var diversity = 45;
		var counts = [0,0,0,0,0,0,0,0,0];
		for (var i = 0; i < 9; i++) 
		{
			diversity -= 1 + counts[view[i].color];
			counts[view[i].color]++;
		}
		if (num_enemies > 0)
		{
			if (diversity >= ERASE_THRESHOLD) return sdec_obstruct_textured();
			else return sdec_obstruct_flat();
		}
		else
		{
			if (diversity >= DISCOLOR_THRESHOLD) return sdec_discolor();
			else if (diversity >= ERASE_THRESHOLD) return sdec_stride();
			else return sdec_erase();
		}
	}
}

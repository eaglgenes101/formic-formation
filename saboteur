/*
function sdecide_alone(facing)
{
}

function sdecide_discolor(facing)
{
}

function sdecide_stride(facing)
{
}

function sdecide_obstruct(facing)
{
}

function sdecide_dogpile(facing)
{
}
*/

//Fallback function for workers
function saboteur()
{
	//Actively avoid other allied workers
	for (try_cell of random_permutation(SCAN_MOVES))
	{
		if (is_ally(try_cell) && view[CCW[try_cell][4]].ant === null) return {cell:CCW[try_cell][4]};
	}

	//Obstruct enemy workers
	for (try_cell of random_permutation(SCAN_MOVES))
		if (is_enemy(try_cell)) 
		{
			if (random_choice(SABOTEUR_RECOLOR_PROB))
			{
				var rand_neighbors = random_subset(NEIGHBORS[try_cell], 2);
				if (rand_neighbors[0] !== rand_neighbors[1])
					return {cell:rand_neighbors[0], color:view[rand_neighbors[1]].color};
			}
			if (random_choice(SABOTEUR_OBSTRUCT_PROB)) return {cell:try_cell};
		}

	var c = UP_PANIC;
	for (try_cell of random_subset(SCAN_MOVES, 7))
		if (view[try_cell].color > 1 && view[try_cell].color !== c) 
		{
			c = view[try_cell].color
			break;
		}

	//If there are more than 2 colored neighbors, settle in and scramble
	//Otherwise, do straight-line motion
	var colored_neighbors = 0;
	for (try_cell of SCAN_MOVES) if (view[try_cell].color > 1) colored_neighbors++;
	if (colored_neighbors > 2)
	{
		//Recolor squares, with a pattern that is surprisingly good at breaking deadlocks
		//TODO: do so with a reduced probability if the pattern is already splotchy
		if (view[1].color !== view[6].color && view[6].color !== 1) return {cell:1, color:view[6].color};
		if (view[2].color !== view[3].color) return {cell:3, color:view[2].color};
		
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 && view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 || view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
	else
	{
		if (view[4].color === 1) return {cell: 4, color: c};

		//Try to move in straight lines
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1 && view[CCW[try_cell][4]].color !== 1) 
				return {cell:try_cell};
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1)
				if (view[CCW[try_cell][2]].color !== 1 && view[CCW[try_cell][6]].color !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
}

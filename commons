//Ant types
const MARCHER_A = 1;
const MARCHER_B = 2;
const GATHERER = 3;
const QUEEN = 5;

//Move attempt order lookup tables
const FREE_ORDER = [
[1,3,6,2,5,7,8],[0,2,5,3,6,8,7],[5,1,0,8,7,3,6],
[6,0,1,7,8,2,5],[],             [2,8,7,1,0,6,3],
[3,7,8,0,1,5,2],[8,6,3,5,2,0,1],[7,5,2,6,3,1,0]];
const RIGHT_ORDER = [
[1,3,6,7],[0,3],[5,1,0,3],
[6,7],    [],   [2,1],
[3,7,8,5],[8,5],[7,5,2,1]];
const LEFT_ORDER = [
[3,1,2,5],[2,5],[1,5,8,7],
[0,1],    [],   [8,7],
[7,3,0,1],[6,3],[5,7,6,3]];

//Spacial information lookup tables
const SCAN_MOVES = [0,1,2,3,5,6,7,8];
const CORNERS = [0,2,6,8];
const EDGES = [1,3,5,7];
const CCW = [
[0,3,6,7,8,5,2,1],[1,0,3,6,7,8,5,2],[2,1,0,3,6,7,8,5],
[3,6,7,8,5,2,1,0],[4,4,4,4,4,4,4,4],[5,2,1,0,3,6,7,8],
[6,7,8,5,2,1,0,3],[7,8,5,2,1,0,3,6],[8,5,2,1,0,3,6,7]];
const NEARS = [
[3,2,0,2,1,0,0,0,0], [2,3,2,1,2,1,0,0,0], [0,2,3,0,1,2,0,0,0],
[2,1,0,3,2,0,2,1,0], [1,2,1,2,3,2,1,2,1], [0,1,2,0,2,3,0,1,2],
[0,0,0,2,1,0,3,2,0], [0,0,0,1,2,1,2,3,2], [0,0,0,0,1,2,0,2,3]];

//Signal colors
const D_MARCH = 1;
const D_FOOD = 2;
const D_STALLED = 3;
const D_GATHERER = 4;
const U_REALIGN = 5;
const U_SENTINEL = 6;
const U_READY = 7;
const U_PANIC = 8;

//Pair reads from upstream (c, side)
const PUPS = [
[0,1,2,3,4,5,6,7,8],
[1,1,0,0,0,1,1,0,1],
[2,0,2,0,4,2,2,0,2],
[3,0,0,3,4,3,3,0,3],
[4,0,4,4,4,4,0,0,4],
[5,1,2,3,4,5,5,0,5],
[6,1,2,3,0,5,5,0,6],
[7,0,0,0,0,0,0,7,7],
[8,1,2,3,4,5,6,7,8]];
//Pair reads from downstream (c, side)
const PDOWNS = [
[0,1,2,3,4,5,6,7,8],
[1,1,0,3,4,5,5,0,1],
[2,0,2,3,4,5,5,0,2],
[3,3,3,3,3,3,3,3,3],
[4,4,4,3,4,0,0,0,4],
[5,5,5,3,0,5,5,0,5],
[6,5,5,3,0,5,5,0,6],
[7,0,0,3,0,0,0,7,7],
[8,1,2,3,4,5,6,7,8]];
//Pair reads from either direction (c, side)
const PSIDES = [
[0,1,2,3,4,5,6,7,8],
[1,1,0,3,4,1,1,0,1],
[2,0,2,0,4,5,5,0,2],
[3,3,0,3,3,3,3,3,3],
[4,4,4,3,4,0,0,0,4],
[5,1,5,3,0,5,5,0,5],
[6,1,5,3,0,5,5,0,6],
[7,0,0,3,0,0,0,7,7],
[8,1,2,3,4,5,6,7,8]];

//Random seeds
const INIT_SEED = 3734978372;
const FINAL_SEED = 2338395782;

//Tuneables
const SABOTEUR_RECOLOR_PROB = 0.8;
const SABOTEUR_OFFSTRIDE_PROB = 0.3;
const QUEEN_SPAWN_PROB_MAX = 0.7;
const QUEEN_SPAWN_PROB_MIN = 0.4;
const QUEEN_SPAWN_PROB_DECAY = 0.05;
const QUEEN_FORM_PROB_MAX = 0.4;
const QUEEN_FORM_PROB_MIN = 0.2;
const QUEEN_FORM_PROB_DECAY = 0.01;
const DISCOLOR_THRESHOLD = 40;
const ERASE_THRESHOLD = 25;
const SABOTEUR_OBSTRUCT_FUZZ = 4;
const OBSTRUCT_QUEEN_WEIGHT = 3;

var state = null;

function rand_init()
{
	state = INIT_SEED;
	for (var cell = 0; cell < 9; cell++)
	{
		var v = view[cell];
		state ^= v.color;
		state ^= v.food << 3;
		if (v.ant !== null)
		{
			state ^= v.ant.friend << 4;
			state ^= v.ant.type << 5;
			state ^= v.ant.food << 8;
		}
		ant_rand(); //Mix it in
	}
	state ^= FINAL_SEED;
	if (state === 0) state = 1;
}

function ant_rand()
{
	if (state === null) rand_init(); //Lazy initialization
	state ^= state << 13;
	state ^= state >>> 17;
	state ^= state << 5;
	return state >>> 0;
}

function rand_choice(prob)
{
	return ant_rand()/4294967296 < prob;
}

function rand_sub(array, num)
{
	var return_array = array.slice();
	for (var i = 0; i < num; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i);
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array.slice(0, num);
}

function rand_perm(array)
{
	var return_array = array.slice();
	for (var i = 0; i < array.length-1; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i)
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array;
}

function index_sort(arr)
{
	var index_array = [];
	for (var i = 0; i < arr.length; i++) index_array.push(i);
	index_array.sort((a,b) => (arr[a] === arr[b])?(a-b):(arr[a] - arr[b]));
	return index_array;
}

function this_ant()
{
	return view[4].ant;
}

function is_ally(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === true;
}

function is_enemy(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === false;
}

function is_harvestable(cell)
{
	return is_enemy(cell) && view[cell].ant.type === QUEEN && view[cell].ant.food > 0;
}

//Movement submission sanitizer
function sanitize(prop, trial_matrix)
{
	//Bounds-checking
	if (prop.cell < 0 || prop.cell > 8) prop.cell = 4;
	if (prop.color < 1 || prop.color > 8) delete prop.color;
	if (prop.type < 1 || prop.type > 4) delete prop.type;

	if (prop.hasOwnProperty("type") && this_ant().type !== QUEEN) delete prop.type;
	if (prop.hasOwnProperty("type"))
	{
		//Check the prop cell first
		if (view[prop.cell].food === 0 && view[prop.cell].ant === null) return prop;
		for (try_cell of rand_perm(trial_matrix[prop.cell]))
			if (view[try_cell].food === 0 && view[try_cell].ant === null)
			{
				prop.cell = try_cell;
				return prop;
			}
		return {cell:4};
	}

	//If we're just coloring spaces, it's fine
	if (prop.hasOwnProperty("color")) return prop;

	//Check the prop cell
	if (view[prop.cell].ant === null)
		if (this_ant().type === QUEEN || this_ant().food === 0 || view[prop.cell].food === 0) return prop;
	for (try_cell of rand_perm(trial_matrix[prop.cell]))
		if (view[try_cell].ant === null && (this_ant().type === QUEEN || this_ant().food === 0 || view[try_cell].food === 0))
		{
			prop.cell = try_cell;
			return prop;
		}
	return {cell:4};
}

//Common line-watching function for signalling and stalled ants
function lchk(c)
{
	if (is_ally(CCW[c][6]) && view[CCW[c][6]].ant.type === GATHERER)
		if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type !== GATHERER) return D_GATHERER;
	if (is_ally(CCW[c][7]) && view[CCW[c][7]].ant.type === GATHERER)
		if (is_ally(CCW[c][1])) return D_GATHERER;
	if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type === GATHERER)
		if (is_ally(CCW[c][3]) && view[4].color === D_MARCH) return D_STALLED;
	if (view[CCW[c][6]].food === 1)
		if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type !== GATHERER) return D_FOOD;
	if (view[CCW[c][7]].food === 1 && is_ally(CCW[c][1]) && view[CCW[c][1]].color === D_FOOD)
		return D_FOOD;
	if (view[CCW[c][5]].food === 1 && is_ally(CCW[c][3]) && view[CCW[c][3]].ant.type !== QUEEN)
		if (view[4].color === D_MARCH) return U_REALIGN;
	return null;
}

function lchk2(c)
{
	if (is_ally(CCW[c][6]) && view[CCW[c][6]].ant.type === GATHERER)
		if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type !== GATHERER) return D_GATHERER;
	if (is_ally(CCW[c][7]) && view[CCW[c][7]].ant.type === GATHERER)
		if (is_ally(CCW[c][1])) return D_GATHERER;
	if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type === GATHERER)
		if (is_ally(CCW[c][3]) && view[4].color === D_MARCH) return D_STALLED;
	if (is_ally(CCW[c][2]) && view[CCW[c][2]].ant.type === GATHERER)
		if (is_ally(CCW[c][1]) && view[CCW[c][1]].ant.type !== GATHERER) return D_GATHERER;
	if (is_ally(CCW[c][3]) && view[CCW[c][3]].ant.type === GATHERER)
		if (is_ally(CCW[c][5]) && view[CCW[c][5]].color === D_GATHERER) return D_GATHERER;
	if (is_ally(CCW[c][1]) && view[CCW[c][1]].ant.type === GATHERER)
		if (is_ally(CCW[c][7]) && view[4].color === D_MARCH) return D_STALLED;
	if (view[CCW[c][6]].food === 1)
		if (is_ally(CCW[c][5]) && view[CCW[c][5]].ant.type !== GATHERER) return D_FOOD;
	if (view[CCW[c][7]].food === 1 && is_ally(CCW[c][1]) && view[CCW[c][1]].color === D_FOOD)
		return D_FOOD;
	if (view[CCW[c][5]].food === 1 && is_ally(CCW[c][3]) && view[CCW[c][3]].ant.type !== QUEEN)
		if (view[4].color === D_MARCH) return U_REALIGN;
	if (view[CCW[c][2]].food === 1)
		if (is_ally(CCW[c][1]) && view[CCW[c][1]].ant.type !== GATHERER) return D_FOOD;
	if (view[CCW[c][3]].food === 1 && is_ally(CCW[c][5]) && view[CCW[c][5]].color === D_FOOD)
		return {cell:4, color:D_FOOD};
	if (view[CCW[c][1]].food === 1 && is_ally(CCW[c][7]) && view[CCW[c][7]].ant.type !== QUEEN)
		if (view[4].color === D_MARCH) return U_REALIGN;
	return null;
}

function sigc(output, c)
{
	if (view[4].color === output)
		for (try_cell of [7,6,5,4,3,2,1,0])
		{
			var off_cell = CCW[c][try_cell];
			if (!is_ally(off_cell) && view[off_cell].color !== D_MARCH)
			{
				if (this_ant().type === QUEEN || view[try_cell].food !== 0) 
					for (alt_cell of SCAN_MOVES)
					{
						var neighbor_weight = NEARS[try_cell][alt_cell];
						if (neighbor_weight > 0 && neighbor_weight < 3)
							if (is_ally(alt_cell) && view[alt_cell].ant.type === GATHERER)
								continue;
					}
				return {cell:CCW[c][try_cell], color:D_MARCH};
			}
		}
	return {cell:4, color:output};
}

function sigc2(output, c)
{
	if (view[4].color === output)
		for (try_cell of [7,3,6,2,5,1,4,0])
		{
			var off_cell = CCW[c][try_cell];
			if (!is_ally(off_cell) && view[off_cell].color !== D_MARCH)
			{
				if (this_ant().type === QUEEN || view[try_cell].food !== 0) 
					for (alt_cell of SCAN_MOVES)
					{
						var neighbor_weight = NEARS[try_cell][alt_cell];
						if (neighbor_weight > 0 && neighbor_weight < 3)
							if (is_ally(alt_cell) && view[alt_cell].ant.type === GATHERER)
								continue;
					}
				return {cell:CCW[c][try_cell], color:D_MARCH};
			}
		}
	return {cell:4, color:output};
}

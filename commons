//Ant types
const MARCHER_A = 1;
const MARCHER_B = 2;
const GATHERER = 3;
const QUEEN = 5;

//Move attempt order lookup tables
const FREE_ORDER = [	[1,3,6,2,5,7,8], 	[0,2,5,3,6,8,7], 	[5,1,0,8,7,3,6],
			[6,0,1,7,8,2,5], 	[],                 	[2,8,7,1,0,6,3],
			[3,7,8,0,1,5,2], 	[8,6,3,5,2,0,1], 	[7,5,2,6,3,1,0]	];
const RIGHT_ORDER = [	[1,3,6,7], 		[0,3], 			[5,1,0,3],
			[6,7],     		[],       		[2,1],
			[3,7,8,5], 		[8,5], 			[7,5,2,1]	];
const LEFT_ORDER = [	[3,1,2,5], 		[2,5], 			[1,5,8,7],
			[0,1],     		[],       		[8,7],
			[7,3,0,1], 		[6,3], 			[5,7,6,3]	];
const NO_ALT = [	[],			[],			[],
			[],			[],			[],
			[],			[],			[]		];

//Spacial information lookup tables
const SCAN_MOVES = 	[0,1,2,3,  5,6,7,8];
const CORNERS = 	[0,  2,      6,  8];
const EDGES = 		[  1,  3,  5,  7  ];
const CCW = [		[0,3,6,7,8,5,2,1],	[1,0,3,6,7,8,5,2],	[2,1,0,3,6,7,8,5],
			[3,6,7,8,5,2,1,0],	[4],			[5,2,1,0,3,6,7,8],
			[6,7,8,5,2,1,0,3],	[7,8,5,2,1,0,3,6],	[8,5,2,1,0,3,6,7]	];
const NEIGHBORS = [	[0,1,3,4],		[1,0,2,3,5,4],		[2,5,1,4],
			[3,6,0,7,1,4],		[1,3,5,7,8,6,2,0,4],	[5,2,8,1,7,4],
			[6,3,7,4],		[7,8,6,5,3,4],		[8,7,5,4]		];
const PRECEDENCES = [	[0,0,0,0,0,0,0,0,0],
			[0,1,2,3,1,5,6,1,1],
			[0,2,2,2,4,2,2,2,2],
			[0,3,2,3,4,3,3,3,3],
			[0,1,4,4,4,4,4,7,4],
			[0,5,2,3,4,5,5,5,5],
			[0,6,2,3,4,5,6,6,6],
			[0,1,2,3,7,5,6,7,7],
			[0,1,2,3,4,5,6,7,8]	];

//Downstream signal colors (travel instantaneously)
const DOWN_MARCH = 1; //We're all ready! Let's go!
const DOWN_FOOD = 2; //We found food!
const DOWN_STALLED = 3; //There's no obstruction, but we're waiting for a ready signal
const DOWN_GATHERER = 4; //Gatherer: "I'm still here!"

//Upstream signal colors (travel at lightspeed)
const UP_REALIGN = 5; //Realign 
const UP_REALIGN_END = 6; //Realign end
const UP_READY = 7; //Ready to move as soon as the end is aligned
const UP_PANIC = 8; //Everyone! Scatter! 

//Random seeds
const INIT_SEED = 3734978372;
const FINAL_SEED = 2338395782;

//Tuneables
SABOTEUR_RECOLOR_PROB = 0.8;
SABOTEUR_OBSTRUCT_PROB = 0.8;
QUEEN_SPAWN_PROB = 0.8;

/*
Functions shared by all ant types
*/

//Xorshift pseudo-rng used to help ants make decisions with probability more granular than 1/4
//There are many situations where the function is _NOT_ applicable, such as in the middle of empty space, 
//so use caution when using the functions defined here
var state = null;

function rand_init()
{
	state = INIT_SEED;
	for (var cell = 0; cell < 9; cell++)
	{
		state ^= view[cell].color;
		state ^= view[cell].food << 3;
		if (view[cell].ant !== null)
		{
			state ^= view[cell].ant.friend << 4;
			state ^= view[cell].ant.type << 5;
			state ^= view[cell].ant.food << 8;
		}
		ant_rand(); //Mix it in
	}
	state ^= FINAL_SEED;
	if (state === 0) state = 1;
}

function ant_rand()
{
	if (state === null) rand_init(); //Lazy initialization
	state ^= state << 13;
	state ^= state >>> 17;
	state ^= state << 5;
	return state >>> 0;
}

//Applications of the output of ant_rand()
function random_choice(prob)
{
	return ant_rand()/4294967296 < prob;
}

//Generate a random permutation
function random_subset(array, num)
{
	var return_array = array.slice();
	for (var i = 0; i < num; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i)
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array.slice(0, num);
}

function random_permutation(array)
{
	var return_array = array.slice();
	for (var i = 0; i < array.length-1; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i)
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array;
}

//Convenience functions condensing common operations
function signal_beats(first, second)
{
	return PRECEDENCE[first][second] === first;
}

function this_ant()
{
	return view[4].ant;
}

function is_ally(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === true;
}

function is_enemy(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === false;
}

function is_harvestable(cell)
{
	return is_enemy(cell) && view[cell].ant.type === QUEEN && view[cell].ant.food > 0;
}

//Movement submission sanitizer
function sanitize(prospective, trial_matrix)
{
	//Bounds-checking
	if (prospective.cell < 0 || prospective.cell > 8) prospective.cell = 4;
	if (prospective.color < 1 || prospective.color > 8) delete prospective.color;
	if (prospective.type < 1 || prospective.type > 4) delete prospective.type;

	//Prevent workers from trying to birth worker ants
	if (prospective.hasOwnProperty("type") && this_ant().type !== QUEEN) delete prospective.type;

	//Prevent birthing of workers in occupied areas
	if (prospective.hasOwnProperty("type"))
	{
		//Check the prospective cell first
		if (view[prospective.cell].food === 0 && view[prospective.cell].ant === null)
			return prospective;
		for (try_cell of random_permutation(trial_matrix[prospective.cell]))
			if (view[try_cell].food === 0 && view[try_cell].ant === null)
			{
				prospective.cell = try_cell;
				return prospective;
			}
		return {cell:4};
	}

	//If we're just coloring spaces, it's fine
	if (prospective.hasOwnProperty("color"))
		return prospective;

	//Check the prospective cell
	if (view[prospective.cell].ant === null)
		if (this_ant().type === QUEEN || this_ant().food === 0 || view[prospective.cell].food === 0)
			return prospective;
	for (try_cell of random_permutation(trial_matrix[prospective.cell]))
		if (view[try_cell].ant === null && (this_ant().type === QUEEN || this_ant().food === 0 || view[try_cell].food === 0))
		{
			prospective.cell = try_cell;
			return prospective;
		}
	return {cell:4};
}

//Fallback function for workers
function saboteur()
{
	//Actively avoid other allied workers
	for (try_cell of random_permutation(SCAN_MOVES))
		if (is_ally(try_cell)) return {cell:CCW[try_cell][4]};

	//Obstruct enemy workers
	for (try_cell of random_permutation(SCAN_MOVES))
		if (is_enemy(try_cell)) 
		{
			if (random_choice(SABOTEUR_RECOLOR_PROB))
			{
				var rand_neighbors = random_subset(NEIGHBORS[try_cell], 2);
				if (rand_neighbors[0] !== rand_neighbors[1])
					return {cell:rand_neighbors[0], color:view[rand_neighbors[1]].color};
			}
			if (random_choice(SABOTEUR_OBSTRUCT_PROB)) return {cell:try_cell};
		}

	var c = this_ant().type+1
	for (try_cell of random_subset(SCAN_MOVES, 7))
		if (view[try_cell].color > 1 && view[try_cell].color !== c) 
		{
			c = view[try_cell].color
			break;
		}

	//If there are more than 2 colored neighbors, settle in and scramble
	//Otherwise, do straight-line motion
	var colored_neighbors = 0;
	for (try_cell of SCAN_MOVES) if (view[try_cell].color > 1) colored_neighbors++;
	if (colored_neighbors > 2)
	{
		//Recolor squares, with a pattern that is surprisingly good at breaking deadlocks
		//TODO: do so with a reduced probability if the pattern is already splotchy
		if (view[1].color !== view[6].color && view[6].color !== 1) return {cell:1, color:view[6].color};
		if (view[2].color !== view[3].color) return {cell:3, color:view[2].color};
		
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 && view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 || view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
	else
	{
		if (view[4].color === 1) return {cell: 4, color: c};

		//Try to move in straight lines
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1 && view[CCW[try_cell][4]].color !== 1) 
				return {cell:try_cell};
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1)
				if (view[CCW[try_cell][2]].color !== 1 && view[CCW[try_cell][6]].color !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
}

function multisig_precedence(candidates)
{
	var wins = new Array(candidates.length);
	for (var i = 0; i < candidates.length; i++)
	{
		for (var j = 0; j < i; j++)
		{
			if (singal_beats(candidates[i], candidates[j])) wins[i]++;
			else wins[j]++;
		}
	}
	var max_count = Math.max( ...wins);
	var has_max_count = [];
	for (var i = 0; i < candidates.length; i++)
		if (wins[i] === max_count) has_max_count.push(i);
	if (has_max_count.length === 1) return has_max_count[0];
	else if (has_max_count.length === candidates.length) return candidates[0];
	else return multisig_precedence(has_max_count);
	
}

function based_precedence(base, candidates)
{
	var allowed = [];
	for (var i = 0; i < candidates.length; i++)
	{
		if (candidates[i] !== base && signal_beats(candidates[i], base)) allowed.push(candidates[i]);
	}
	if (allowed.length === 0) allowed.concat(candidates);
	return multisig_precedence(allowed);
	
}






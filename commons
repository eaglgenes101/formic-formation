//Ant types
const MARCHER_A = 1;
const MARCHER_B = 2;
const GATHERER = 3;
const QUEEN = 5;

//Move attempt order lookup tables
const FREE_ORDER = [	[1,3,6,2,5,7,8], 	[0,2,5,3,6,8,7], 	[5,1,0,8,7,3,6],
			[6,0,1,7,8,2,5], 	[],                 	[2,8,7,1,0,6,3],
			[3,7,8,0,1,5,2], 	[8,6,3,5,2,0,1], 	[7,5,2,6,3,1,0]	];
const RIGHT_ORDER = [	[1,3,6,7], 		[0,3], 			[5,1,0,3],
			[6,7],     		[],       		[2,1],
			[3,7,8,5], 		[8,5], 			[7,5,2,1]	];
const LEFT_ORDER = [	[3,1,2,5], 		[2,5], 			[1,5,8,7],
			[0,1],     		[],       		[8,7],
			[7,3,0,1], 		[6,3], 			[5,7,6,3]	];
const NO_ALT = [	[],			[],			[],
			[],			[],			[],
			[],			[],			[]		];

//Spacial information lookup tables
const SCAN_MOVES = 	[0,1,2,3,  5,6,7,8];
const CORNERS = 	[0,  2,      6,  8];
const EDGES = 		[  1,  3,  5,  7  ];
const CCW = [		[0,3,6,7,8,5,2,1],	[1,0,3,6,7,8,5,2],	[2,1,0,3,6,7,8,5],
			[3,6,7,8,5,2,1,0],	[4],			[5,2,1,0,3,6,7,8],
			[6,7,8,5,2,1,0,3],	[7,8,5,2,1,0,3,6],	[8,5,2,1,0,3,6,7]	];
const NEIGHBORS = [	[0,1,3,4],		[1,0,2,3,5,4],		[2,5,1,4],
			[3,6,0,7,1,4],		[1,3,5,7,8,6,2,0,4],	[5,2,8,1,7,4],
			[6,3,7,4],		[7,8,6,5,3,4],		[8,7,5,4]		];
const NEARS = [		[0,1,3],		[1,0,2,4],		[2,5,1],
			[3,6,0,7],		[1,3,5,7,4],		[5,2,8,4],
			[6,3,7],		[7,8,6,4],		[8,7,5]			];
//Downstream signal colors (travel instantaneously)
const DOWN_MARCH = 1; //We're all ready! Let's go!
const DOWN_FOOD = 2; //We found food!
const DOWN_STALLED = 3; //There's no obstruction, but we're waiting for a ready signal
const DOWN_GATHERER = 4; //Gatherer: "I'm still here!"

//Upstream signal colors (travel at lightspeed)
const UP_REALIGN = 5; //Realign 
const UP_REALIGN_END = 6; //Realign end
const UP_READY = 7; //Ready to move as soon as the end is aligned
const UP_PANIC = 8; //Everyone! Scatter! 

//Pair reads from upstream (corner, side)
const PAIRUPS = [	[0,1,2,3,4,5,6,7,8],
			[1,1,0,0,0,1,1,0,1],
			[2,0,2,0,4,2,2,0,2],
			[3,0,0,3,4,3,3,0,3],
			[4,0,4,4,4,4,0,0,4],
			[5,1,2,3,4,5,5,0,5],
			[6,1,2,3,0,5,5,0,6],
			[7,0,0,0,0,0,0,7,7],
			[8,1,2,3,4,5,6,7,8]	];
//Pair reads from downstream (corner, side)
const PAIRDOWNS = [	[0,1,2,3,4,5,6,7,8],
			[1,1,0,3,4,5,5,0,1],
			[2,0,2,3,4,5,5,0,2],
			[3,3,3,3,3,3,3,3,3],
			[4,4,4,3,4,0,0,0,4],
			[5,5,5,3,0,5,5,0,5],
			[6,5,5,3,0,5,5,0,6],
			[7,0,0,3,0,0,0,7,7],
			[8,1,2,3,4,5,6,7,8]	];
//Pair reads from either direction (corner, side)
const PAIRSIDES = [	[0,1,2,3,4,5,6,7,8],
			[1,1,0,3,4,1,1,0,1],
			[2,0,2,0,4,5,5,0,2],
			[3,3,0,3,3,3,3,3,3],
			[4,4,4,3,4,0,0,0,4],
			[5,1,5,3,0,5,5,0,5],
			[6,1,5,3,0,5,5,0,6],
			[7,0,0,3,0,0,0,7,7],
			[8,1,2,3,4,5,6,7,8]	];


//Random seeds
const INIT_SEED = 3734978372;
const FINAL_SEED = 2338395782;

//Tuneables
const SABOTEUR_RECOLOR_PROB = 0.8;
const SABOTEUR_OBSTRUCT_PROB = 0.8;
const QUEEN_SPAWN_PROB_MIN = 0.8;
const QUEEN_SPAWN_PROB_DECAY = 0.01;
const QUEEN_FORM_PROB_MAX = 0.5;
const QUEEN_FORM_PROB_MIN = 0.15;
const QUEEN_FORM_PROB_DECAY = 0.01;

/*
Functions shared by all ant types
*/

//Xorshift pseudo-rng used to help ants make decisions with probability more granular than 1/4
//There are many situations where the function is _NOT_ applicable, such as in the middle of empty space, 
//so use caution when using the functions defined here
var state = null;

function rand_init()
{
	state = INIT_SEED;
	for (var cell = 0; cell < 9; cell++)
	{
		state ^= view[cell].color;
		state ^= view[cell].food << 3;
		if (view[cell].ant !== null)
		{
			state ^= view[cell].ant.friend << 4;
			state ^= view[cell].ant.type << 5;
			state ^= view[cell].ant.food << 8;
		}
		ant_rand(); //Mix it in
	}
	state ^= FINAL_SEED;
	if (state === 0) state = 1;
}

function ant_rand()
{
	if (state === null) rand_init(); //Lazy initialization
	state ^= state << 13;
	state ^= state >>> 17;
	state ^= state << 5;
	return state >>> 0;
}

//Applications of the output of ant_rand()
function random_choice(prob)
{
	return ant_rand()/4294967296 < prob;
}

//Generate a random permutation
function random_subset(array, num)
{
	var return_array = array.slice();
	for (var i = 0; i < num; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i)
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array.slice(0, num);
}

function random_permutation(array)
{
	var return_array = array.slice();
	for (var i = 0; i < array.length-1; i++)
	{
		var rand_index = i + ant_rand()%(array.length - i)
		var x_val = return_array[rand_index];
		return_array[rand_index] = return_array[i];
		return_array[i] = x_val;
	}
	return return_array;
}

function this_ant()
{
	return view[4].ant;
}

function is_ally(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === true;
}

function is_enemy(cell)
{
	return view[cell].ant !== null && view[cell].ant.friend === false;
}

function is_harvestable(cell)
{
	return is_enemy(cell) && view[cell].ant.type === QUEEN && view[cell].ant.food > 0;
}

//Movement submission sanitizer
function sanitize(prospective, trial_matrix)
{
	//Bounds-checking
	if (prospective.cell < 0 || prospective.cell > 8) prospective.cell = 4;
	if (prospective.color < 1 || prospective.color > 8) delete prospective.color;
	if (prospective.type < 1 || prospective.type > 4) delete prospective.type;

	//Prevent workers from trying to birth worker ants
	if (prospective.hasOwnProperty("type") && this_ant().type !== QUEEN) delete prospective.type;

	//Prevent birthing of workers in occupied areas
	if (prospective.hasOwnProperty("type"))
	{
		//Check the prospective cell first
		if (view[prospective.cell].food === 0 && view[prospective.cell].ant === null)
			return prospective;
		for (try_cell of random_permutation(trial_matrix[prospective.cell]))
			if (view[try_cell].food === 0 && view[try_cell].ant === null)
			{
				prospective.cell = try_cell;
				return prospective;
			}
		return {cell:4};
	}

	//If we're just coloring spaces, it's fine
	if (prospective.hasOwnProperty("color"))
		return prospective;

	//Check the prospective cell
	if (view[prospective.cell].ant === null)
		if (this_ant().type === QUEEN || this_ant().food === 0 || view[prospective.cell].food === 0)
			return prospective;
	for (try_cell of random_permutation(trial_matrix[prospective.cell]))
		if (view[try_cell].ant === null && (this_ant().type === QUEEN || this_ant().food === 0 || view[try_cell].food === 0))
		{
			prospective.cell = try_cell;
			return prospective;
		}
	return {cell:4};
}

//Fallback function for workers
function saboteur()
{
	//Actively avoid other allied workers
	for (try_cell of random_permutation(SCAN_MOVES))
	{
		if (is_ally(try_cell) && view[CCW[try_cell][4]].ant === null) return {cell:CCW[try_cell][4]};
	}

	//Obstruct enemy workers
	for (try_cell of random_permutation(SCAN_MOVES))
		if (is_enemy(try_cell)) 
		{
			if (random_choice(SABOTEUR_RECOLOR_PROB))
			{
				var rand_neighbors = random_subset(NEIGHBORS[try_cell], 2);
				if (rand_neighbors[0] !== rand_neighbors[1])
					return {cell:rand_neighbors[0], color:view[rand_neighbors[1]].color};
			}
			if (random_choice(SABOTEUR_OBSTRUCT_PROB)) return {cell:try_cell};
		}

	var c = UP_PANIC;
	for (try_cell of random_subset(SCAN_MOVES, 7))
		if (view[try_cell].color > 1 && view[try_cell].color !== c) 
		{
			c = view[try_cell].color
			break;
		}

	//If there are more than 2 colored neighbors, settle in and scramble
	//Otherwise, do straight-line motion
	var colored_neighbors = 0;
	for (try_cell of SCAN_MOVES) if (view[try_cell].color > 1) colored_neighbors++;
	if (colored_neighbors > 2)
	{
		//Recolor squares, with a pattern that is surprisingly good at breaking deadlocks
		//TODO: do so with a reduced probability if the pattern is already splotchy
		if (view[1].color !== view[6].color && view[6].color !== 1) return {cell:1, color:view[6].color};
		if (view[2].color !== view[3].color) return {cell:3, color:view[2].color};
		
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 && view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};
		for (try_cell of random_permutation(EDGES))
			if (view[try_cell].color !== 1) 
				if (view[CCW[try_cell][1]] !== 1 || view[CCW[try_cell][7]] !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
	else
	{
		if (view[4].color === 1) return {cell: 4, color: c};

		//Try to move in straight lines
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1 && view[CCW[try_cell][4]].color !== 1) 
				return {cell:try_cell};
		for (try_cell of random_permutation(CORNERS))
			if (view[try_cell].color === 1)
				if (view[CCW[try_cell][2]].color !== 1 && view[CCW[try_cell][6]].color !== 1) 
					return {cell:try_cell};

		return {cell:1};
	}
}

//Common line-watching function for signalling and stalled ants
function linewatch(corner)
{
	if (is_ally(CCW[corner][6]) && view[CCW[corner][6]].ant.type === GATHERER)
	{
		if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type !== GATHERER)
			return DOWN_GATHERER;
	}
	if (is_ally(CCW[corner][7]) && view[CCW[corner][7]].ant.type === GATHERER)
		if (is_ally(CCW[corner][1]))
			return DOWN_GATHERER;
	if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type === GATHERER)
		if (is_ally(CCW[corner][3]) && view[4].color === DOWN_MARCH)
			return DOWN_STALLED;
	if (view[CCW[corner][6]].food === 1)
	{
		if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type !== GATHERER)
			return DOWN_FOOD;
	}
	if (view[CCW[corner][7]].food === 1 && is_ally(CCW[corner][1]) && view[CCW[corner][1]].color === DOWN_FOOD)
		return DOWN_FOOD;
	if (view[CCW[corner][5]].food === 1 && is_ally(CCW[corner][3]) && view[CCW[corner][3]].ant.type !== QUEEN)
		if (view[4].color === DOWN_MARCH)
			return UP_REALIGN;
	return null;
}

function linewatch2(corner)
{
	if (is_ally(CCW[corner][6]) && view[CCW[corner][6]].ant.type === GATHERER)
	{
		if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type !== GATHERER)
			return DOWN_GATHERER;
	}
	if (is_ally(CCW[corner][7]) && view[CCW[corner][7]].ant.type === GATHERER)
		if (is_ally(CCW[corner][1]))
			return DOWN_GATHERER;
	if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type === GATHERER)
		if (is_ally(CCW[corner][3]) && view[4].color === DOWN_MARCH)
			return DOWN_STALLED;
	if (is_ally(CCW[corner][2]) && view[CCW[corner][2]].ant.type === GATHERER)
	{
		if (is_ally(CCW[corner][1]) && view[CCW[corner][1]].ant.type !== GATHERER)
			return DOWN_GATHERER;
	}
	if (is_ally(CCW[corner][3]) && view[CCW[corner][3]].ant.type === GATHERER)
		if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].color === DOWN_GATHERER)
			return DOWN_GATHERER;
	if (is_ally(CCW[corner][1]) && view[CCW[corner][1]].ant.type === GATHERER)
		if (is_ally(CCW[corner][7]) && view[4].color === DOWN_MARCH)
			return DOWN_STALLED;
	if (view[CCW[corner][6]].food === 1)
	{
		if (is_ally(CCW[corner][5]) && view[CCW[corner][5]].ant.type !== GATHERER)
			return DOWN_FOOD;
	}
	if (view[CCW[corner][7]].food === 1 && is_ally(CCW[corner][1]) && view[CCW[corner][1]].color === DOWN_FOOD)
		return DOWN_FOOD;
	if (view[CCW[corner][5]].food === 1 && is_ally(CCW[corner][3]) && view[CCW[corner][3]].ant.type !== QUEEN)
		if (view[4].color === DOWN_MARCH)
			return UP_REALIGN;
	if (view[CCW[corner][2]].food === 1)
	{
		if (is_ally(CCW[corner][1]) && view[CCW[corner][1]].ant.type !== GATHERER)
			return DOWN_FOOD;
	}
	if (view[CCW[corner][3]].food === 1 && is_ally(CCW[corner][5]) && view[CCW[corner][5]].color === DOWN_FOOD)
		return {cell:4, color:DOWN_FOOD};
	if (view[CCW[corner][1]].food === 1 && is_ally(CCW[corner][7]) && view[CCW[corner][7]].ant.type !== QUEEN)
		if (view[4].color === DOWN_MARCH)
			return UP_REALIGN;
	return null;
}

function turn_color(output, corner)
{
	if (view[4].color === output)
	{
		if (!is_ally(CCW[corner][7]) && view[CCW[corner][7]].color !== DOWN_MARCH)
			return {cell:CCW[corner][7], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][6]) && view[CCW[corner][6]].color !== DOWN_MARCH)
			return {cell:CCW[corner][6], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][5]) && view[CCW[corner][5]].color !== DOWN_MARCH)
			return {cell:CCW[corner][5], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][4]) && view[CCW[corner][4]].color !== DOWN_MARCH)
			return {cell:CCW[corner][4], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][3]) && view[CCW[corner][3]].color !== DOWN_MARCH)
			return {cell:CCW[corner][3], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][2]) && view[CCW[corner][2]].color !== DOWN_MARCH)
			return {cell:CCW[corner][2], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][1]) && view[CCW[corner][1]].color !== DOWN_MARCH)
			return {cell:CCW[corner][1], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][0]) && view[CCW[corner][0]].color !== DOWN_MARCH)
			return {cell:CCW[corner][0], color:DOWN_MARCH};
	}
	return {cell:4, color:output};
}

function turn_color2(output, corner)
{
	if (view[4].color === output)
	{
		if (!is_ally(CCW[corner][7]) && view[CCW[corner][7]].color !== DOWN_MARCH)
			return {cell:CCW[corner][7], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][3]) && view[CCW[corner][3]].color !== DOWN_MARCH)
			return {cell:CCW[corner][3], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][6]) && view[CCW[corner][6]].color !== DOWN_MARCH)
			return {cell:CCW[corner][6], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][2]) && view[CCW[corner][2]].color !== DOWN_MARCH)
			return {cell:CCW[corner][2], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][5]) && view[CCW[corner][5]].color !== DOWN_MARCH)
			return {cell:CCW[corner][5], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][1]) && view[CCW[corner][1]].color !== DOWN_MARCH)
			return {cell:CCW[corner][1], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][4]) && view[CCW[corner][4]].color !== DOWN_MARCH)
			return {cell:CCW[corner][4], color:DOWN_MARCH};
		if (!is_ally(CCW[corner][0]) && view[CCW[corner][0]].color !== DOWN_MARCH)
			return {cell:CCW[corner][0], color:DOWN_MARCH};
	}
	return {cell:4, color:output};
}
